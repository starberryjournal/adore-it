from fastapi import FastAPI, HTTPException
from appwrite.client import Client
from appwrite.services.database import Database
from appwrite.services.storage import Storage
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from torchvision import models
from PIL import Image
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import requests
from io import BytesIO
from fastapi.responses import JSONResponse

# Initialize FastAPI app
app = FastAPI()

# Initialize the Appwrite client
client = Client()
client.set_endpoint('https://cloud.appwrite.io/v1')  # Replace with your Appwrite endpoint
client.set_project('67bc93bc0004228cf938')  # Replace with your Appwrite project ID
client.set_key('WriteKey')  # Replace with your Appwrite API key (if needed)

# Initialize Appwrite services
database = Database(client)
storage = Storage(client)

# Load ResNet model for feature extraction
resnet = models.resnet18(pretrained=True)
resnet.eval()
resnet = nn.Sequential(*list(resnet.children())[:-1])  # Remove the classification layer

# Image transformation
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

def extract_features_from_image(image_data):
    img = Image.open(BytesIO(image_data)).convert("RGB")
    img = transform(img).unsqueeze(0)
    with torch.no_grad():
        features = resnet(img)
    return features.squeeze().numpy()

def fetch_all_posts(collection_id):
    posts = []
    try:
        response = database.list_documents(collection_id=collection_id)
        posts = response['documents']
    except Exception as e:
        print(f"Failed to fetch posts: {e}")
    return posts

def fetch_images_from_bucket(bucket_id, limit=50):
    images = []
    image_features = []
    offset = 0
    while True:
        files = storage.list_files(bucket_id=bucket_id, limit=limit, offset=offset)
        for file in files['files']:
            file_id = file['$id']
            file_name = file['name']
            file_url = storage.get_file_download(bucket_id=bucket_id, file_id=file_id).get_url()
            image_data = download_image(file_url)
            if image_data:
                features = extract_features_from_image(image_data)
                images.append(file_name)
                image_features.append(features)
        if len(files['files']) < limit:
            break
        offset += limit
    return images, np.array(image_features)

def download_image(url):
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        return response.content
    except requests.exceptions.RequestException as e:
        print(f"Failed to download image from {url}: {e}")
        return None

@app.get("/similar-images/{image_file_id}")
async def get_similar_images(image_file_id: str):
    # Fetch all posts and images as you did before
    posts = fetch_all_posts('67be4e9e001142383751')  # Replace with your collection ID
    images, image_features = fetch_images_from_bucket('67be51020004776eea1a')  # Replace with your bucket ID

    # Find the post with the specified imageFileId
    postDoc = next((post for post in posts if post.get('imageFileId') == image_file_id), None)
    if not postDoc:
        raise HTTPException(status_code=404, detail="Post or image not found")

    # Get the current image URL for the provided imageFileId
    current_image_url = f'http://localhost:3000/image/{image_file_id}'

    # Download and process the image
    current_image_data = download_image(current_image_url)
    if not current_image_data:
        raise HTTPException(status_code=500, detail="Error downloading the current image")

    # Extract features for the current image
    current_image_features = extract_features_from_image(current_image_data)

    # Calculate cosine similarity between the current image and all others
    similarities = cosine_similarity([current_image_features], image_features)

    # Get the top 5 most similar images
    similar_images_idx = np.argsort(similarities[0])[::-1][:5]
    similar_images = [images[idx] for idx in similar_images_idx]

    return JSONResponse(content={"similar_images": similar_images})

